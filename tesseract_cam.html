<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tesseract Installation — Flickr Shelves</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; }
    #app { position:fixed; inset:0; }

    #hud {
      position:fixed; left:12px; top:12px; color:#eaeaea;
      font: 12px/1.45 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 10px 12px;
      max-width: min(720px, calc(100vw - 24px));
      backdrop-filter: blur(8px);
      user-select:none;
      z-index: 10;
    }
    #hud b { color:#fff; }
    #hud .row { opacity:.92; }
    #hud .dim { opacity:.65; }
    #hud input {
      width: 260px;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.35);
      color: #fff;
      outline: none;
      margin-left: 8px;
    }
    #hud button {
      margin-left: 8px;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.35);
      color: #fff;
      cursor: pointer;
    }

    #toast {
      position:fixed; right:12px; bottom:12px;
      color:#fff; font: 12px ui-monospace, monospace;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 8px 10px;
      opacity:0; transform: translateY(6px);
      transition: opacity .25s ease, transform .25s ease;
      pointer-events:none;
      z-index: 20;
    }
    #toast.show { opacity:1; transform: translateY(0); }

    canvas { display:block; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="hud">
    <div class="row"><b>Tesseract Installation</b> — Flickr → 4s interval → layer-decomposed shelves</div>
    <div class="row dim">棚（前面）：上=輪郭 / 中=低周波(ぼかし) / 下=高周波(テクスチャ)</div>
    <div class="row dim">棚（背面）：差分（前回画像との差）</div>

    <div class="row" style="margin-top:8px;">
      Flickr tags:
      <input id="tags" value="space,nebula,night" />
      <button id="apply">Apply</button>
      <button id="pause">Pause</button>
    </div>

    <div class="row dim" style="margin-top:6px;">
      Mouse: ドラッグ回転 / Wheel: ズーム　Keys: <b>H</b> HUD, <b>F</b> Fullscreen, <b>M</b> Mirror, <b>C</b> Color, <b>[</b>/<b>]</b> slices, <b>1</b> shelves, <b>2</b> tesseract, <b>3</b> dust
    </div>
  </div>

  <div id="toast"></div>

<script type="module">
/* ---------------------------------------------------------
   Imports (NO importmap): works on GitHub Pages + Firefox
--------------------------------------------------------- */
import * as THREE from 'https://esm.sh/three@0.160.0';
import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';

/* ------------------------------
   Utils
-------------------------------- */
const clamp = (x, a, b) => Math.min(b, Math.max(a, x));
const lerp  = (a, b, t) => a + (b - a) * t;

const toastEl = document.getElementById('toast');
let toastTimer = 0;
function toast(msg){
  toastEl.textContent = msg;
  toastEl.classList.add('show');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(()=> toastEl.classList.remove('show'), 1200);
}

/* ------------------------------
   Flickr Public Feed (JSONP, no API key)
   - tags=comma,separated
   - returns { items: [ { media: { m: url }, title, author, link, ... }, ... ] }
-------------------------------- */
function fetchFlickrPublicFeed(tags){
  return new Promise((resolve, reject)=>{
    const cb = `__flickr_cb_${Math.random().toString(36).slice(2)}`;
    const script = document.createElement('script');

    const clean = (ok, payload)=>{
      try { delete window[cb]; } catch {}
      script.remove();
      ok ? resolve(payload) : reject(payload);
    };

    window[cb] = (data)=> clean(true, data);

    // public feed supports jsoncallback=...
    const url = new URL('https://www.flickr.com/services/feeds/photos_public.gne');
    url.searchParams.set('format', 'json');
    url.searchParams.set('nojsoncallback', '0'); // keep JSONP
    url.searchParams.set('jsoncallback', cb);
    url.searchParams.set('tags', tags || 'space,nebula,night');

    script.src = url.toString();
    script.onerror = ()=> clean(false, new Error('Failed to load Flickr feed (script error)'));
    document.head.appendChild(script);

    // timeout safety
    setTimeout(()=>{
      if (window[cb]) clean(false, new Error('Flickr feed timeout'));
    }, 8000);
  });
}

async function loadImage(url){
  // Try to load with CORS so canvas->WebGL upload stays valid.
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = ()=> resolve(img);
    img.onerror = ()=> reject(new Error('Image load failed'));
    img.src = url;
  });
}

/* ------------------------------
   Atlas: shelves store 4 bands per photo:
   [0] edge, [1] low-pass blur, [2] high-pass, [3] diff vs previous photo
-------------------------------- */
let slices = 36;               // number of photos stored
let intervalSec = 4.0;         // every 4 seconds
let lastInsertT = -999;

let atlasW = 640;
let baseSliceH = 360;
let sliceH = baseSliceH * 4;
let atlasH = sliceH * slices;

const atlas = document.createElement('canvas');
const actx = atlas.getContext('2d', { willReadFrequently: true });

// Firefox-safe shift buffer (avoid drawing atlas onto itself)
const shiftC = document.createElement('canvas');
const shiftCtx = shiftC.getContext('2d', { willReadFrequently: true });

// temp canvases for layer processing (NO getImageData route by design)
const origC = document.createElement('canvas');
const blurC = document.createElement('canvas');
const edgeC = document.createElement('canvas');
const highC = document.createElement('canvas');
const diffC = document.createElement('canvas');
const prevC = document.createElement('canvas'); // previous photo for diff

function resizeAtlasForAspect(vw, vh){
  atlasW = 640;
  baseSliceH = Math.round(atlasW * (vh / vw));
  sliceH = baseSliceH * 4;
  atlasH = sliceH * slices;

  atlas.width = atlasW;
  atlas.height = atlasH;
  actx.fillStyle = '#000';
  actx.fillRect(0,0,atlasW,atlasH);

  // shift buffer holds atlas excluding top shelf
  shiftC.width = atlasW;
  shiftC.height = Math.max(1, atlasH - sliceH);

  for (const c of [origC, blurC, edgeC, highC, diffC, prevC]){
    c.width = atlasW;
    c.height = baseSliceH;
  }
}

resizeAtlasForAspect(16, 9);

/* draw image into origC with cover-crop */
let mirror = true;
function drawImageCover(ctx, img){
  const cw = atlasW, ch = baseSliceH;
  const iw = img.naturalWidth || img.width;
  const ih = img.naturalHeight || img.height;

  const scale = Math.max(cw / iw, ch / ih);
  const sw = cw / scale;
  const sh = ch / scale;
  const sx = (iw - sw) * 0.5;
  const sy = (ih - sh) * 0.5;

  ctx.save();
  ctx.clearRect(0,0,cw,ch);
  if (mirror){
    ctx.translate(cw, 0);
    ctx.scale(-1, 1);
  }
  ctx.drawImage(img, sx, sy, sw, sh, 0, 0, cw, ch);
  ctx.restore();
}

function genFallbackNoise(ctx, t){
  const img = ctx.createImageData(atlasW, baseSliceH);
  for (let i=0; i<img.data.length; i+=4){
    const x = ((i/4) % atlasW) / atlasW;
    const y = Math.floor((i/4) / atlasW) / baseSliceH;
    const v = (Math.sin(20*x + 7*y + t*2) + Math.sin(13*x - 11*y + t*1.3)) * 0.5;
    const n = (v*0.5+0.5) * 255;
    img.data[i+0] = n;
    img.data[i+1] = n*0.8;
    img.data[i+2] = n*0.6;
    img.data[i+3] = 255;
  }
  ctx.putImageData(img, 0, 0);
}

/* layer decomposition using composite-only (no pixel reads) */
function buildLayersFromOrig(t){
  const octx = origC.getContext('2d', { willReadFrequently:true });
  const bctx = blurC.getContext('2d', { willReadFrequently:true });
  const ectx = edgeC.getContext('2d', { willReadFrequently:true });
  const hctx = highC.getContext('2d', { willReadFrequently:true });
  const dctx = diffC.getContext('2d', { willReadFrequently:true });
  const pctx = prevC.getContext('2d', { willReadFrequently:true });

  // low-pass blur
  bctx.save();
  bctx.clearRect(0,0,atlasW,baseSliceH);
  bctx.filter = 'blur(12px)';
  bctx.drawImage(origC, 0, 0);
  bctx.restore();

  // edge (pseudo): difference of shifted copies
  ectx.save();
  ectx.clearRect(0,0,atlasW,baseSliceH);
  ectx.filter = 'contrast(280%)';
  ectx.globalCompositeOperation = 'source-over';
  ectx.drawImage(origC, 0, 0);
  ectx.globalCompositeOperation = 'difference';
  ectx.drawImage(origC, 1, 0);
  ectx.drawImage(origC, 0, 1);
  ectx.globalCompositeOperation = 'source-over';
  ectx.restore();

  // high-pass: gray then difference(orig, blur)
  hctx.save();
  hctx.clearRect(0,0,atlasW,baseSliceH);
  hctx.filter = 'contrast(190%) brightness(110%)';
  hctx.fillStyle = 'rgb(128,128,128)';
  hctx.fillRect(0,0,atlasW,baseSliceH);
  hctx.globalCompositeOperation = 'difference';
  hctx.drawImage(blurC, 0, 0);
  hctx.globalCompositeOperation = 'difference';
  hctx.drawImage(origC, 0, 0);
  hctx.globalCompositeOperation = 'source-over';
  hctx.restore();

  // diff vs previous photo
  dctx.save();
  dctx.clearRect(0,0,atlasW,baseSliceH);
  dctx.filter = 'contrast(320%)';
  dctx.globalCompositeOperation = 'source-over';
  dctx.drawImage(origC, 0, 0);
  dctx.globalCompositeOperation = 'difference';
  dctx.drawImage(prevC, 0, 0);
  dctx.globalCompositeOperation = 'source-over';
  dctx.restore();

  // update prevC = orig
  pctx.clearRect(0,0,atlasW,baseSliceH);
  pctx.drawImage(origC, 0, 0);
}

/* shift shelves down (Firefox-safe), then write top shelf bands */
function insertTopShelf(){
  const copyH = atlasH - sliceH;
  if (copyH > 0){
    shiftCtx.clearRect(0,0,shiftC.width,shiftC.height);
    shiftCtx.drawImage(atlas, 0, 0, atlasW, copyH, 0, 0, atlasW, copyH);
    actx.drawImage(shiftC, 0, 0, atlasW, copyH, 0, sliceH, atlasW, copyH);
  }

  // write bands into top shelf
  actx.drawImage(edgeC, 0, 0, atlasW, baseSliceH, 0, 0*baseSliceH, atlasW, baseSliceH);
  actx.drawImage(blurC, 0, 0, atlasW, baseSliceH, 0, 1*baseSliceH, atlasW, baseSliceH);
  actx.drawImage(highC, 0, 0, atlasW, baseSliceH, 0, 2*baseSliceH, atlasW, baseSliceH);
  actx.drawImage(diffC, 0, 0, atlasW, baseSliceH, 0, 3*baseSliceH, atlasW, baseSliceH);

  // slight fade
  actx.fillStyle = 'rgba(0,0,0,0.03)';
  actx.fillRect(0,0,atlasW,sliceH);
}

/* ------------------------------
   Feed buffer management
-------------------------------- */
let currentTags = document.getElementById('tags').value.trim();
let feedQueue = [];
let inFlightFetch = false;

async function refillQueue(){
  if (inFlightFetch) return;
  inFlightFetch = true;
  try{
    const data = await fetchFlickrPublicFeed(currentTags);
    const urls = (data?.items || [])
      .map(it => it?.media?.m)
      .filter(Boolean);

    // shuffle a bit
    for (let i = urls.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [urls[i], urls[j]] = [urls[j], urls[i]];
    }
    feedQueue = urls;
    toast(`Flickr loaded: ${feedQueue.length} items`);
  }catch(e){
    console.error(e);
    toast('Flickr fetch failed (fallback noise)');
    feedQueue = [];
  }finally{
    inFlightFetch = false;
  }
}

async function nextPhoto(){
  if (feedQueue.length < 6) refillQueue(); // async
  const url = feedQueue.shift();
  if (!url) return null;

  try{
    const img = await loadImage(url);
    return { img, url };
  }catch(e){
    console.warn('Image failed:', url, e);
    return null;
  }
}

/* ------------------------------
   Three.js scene
-------------------------------- */
const app = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x000000, 1);
app.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.045);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 200);
camera.position.set(0, 0.9, 3.2);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;

scene.add(new THREE.AmbientLight(0xffffff, 0.25));
const dir = new THREE.DirectionalLight(0xffffff, 0.55);
dir.position.set(2, 3, 1);
scene.add(dir);

/* atlas texture */
const atlasTex = new THREE.CanvasTexture(atlas);
atlasTex.minFilter = THREE.LinearFilter;
atlasTex.magFilter = THREE.LinearFilter;
atlasTex.wrapS = THREE.ClampToEdgeWrapping;
atlasTex.wrapT = THREE.ClampToEdgeWrapping;

/* shader uniforms */
let colorMode = 0;
let motion = 0.12;            // synthetic motion
let motionPulse = 0.0;        // pulse when new photo inserted

const baseUniforms = {
  uAtlas: { value: atlasTex },
  uAtlasSize: { value: new THREE.Vector2(atlasW, atlasH) },
  uSliceH: { value: sliceH },
  uSlices: { value: slices },
  uTime: { value: 0 },
  uSliceIndex: { value: 0 },
  uMotion: { value: 0 },
  uColorMode: { value: colorMode },
  uGain: { value: 1.15 },
  uLayerMode: { value: 0 } // 0=front, 1=diff-only
};

const shelvesMat = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  uniforms: baseUniforms,
  vertexShader: /* glsl */`
    varying vec2 vUv;
    varying float vDepth;
    void main(){
      vUv = uv;
      vec4 mv = modelViewMatrix * vec4(position, 1.0);
      vDepth = -mv.z;
      gl_Position = projectionMatrix * mv;
    }
  `,
  fragmentShader: /* glsl */`
    precision highp float;
    varying vec2 vUv;
    varying float vDepth;

    uniform sampler2D uAtlas;
    uniform vec2 uAtlasSize;
    uniform float uSliceH;
    uniform float uSlices;
    uniform float uTime;
    uniform float uSliceIndex;
    uniform float uMotion;
    uniform int uColorMode;
    uniform float uGain;
    uniform int uLayerMode;

    float hash21(vec2 p){
      p = fract(p*vec2(123.34, 345.45));
      p += dot(p, p+34.345);
      return fract(p.x*p.y);
    }
    vec3 tonemap(vec3 c){
      c = max(c, 0.0);
      c = c / (1.0 + c);
      return pow(c, vec3(0.95));
    }

    void main(){
      float slice = uSliceIndex;
      float sliceV0 = slice * (uSliceH / uAtlasSize.y);
      float shelfH  = (uSliceH / uAtlasSize.y);
      float bandH   = shelfH * 0.25;

      float m = uMotion;
      float t = uTime;

      vec2 uv = vUv;
      vec2 p  = uv - 0.5;
      float r = length(p);

      float depthFactor = clamp((slice / max(uSlices-1.0, 1.0)), 0.0, 1.0);
      float lens = (0.10 + 0.32*m) * (0.35 + depthFactor);
      p *= (1.0 + lens * r*r);

      float swirl = (0.18 + 0.62*m) * (0.25 + depthFactor);
      float ang = swirl * sin(t*0.7 + depthFactor*6.283 + p.x*2.0 - p.y*2.0);
      float cs = cos(ang), sn = sin(ang);
      p = mat2(cs, -sn, sn, cs) * p;

      float ca = (0.002 + 0.01*m) * (0.35 + r);
      vec2 uvR = p + 0.5 + ca * normalize(p + 1e-5);
      vec2 uvG = p + 0.5;
      vec2 uvB = p + 0.5 - ca * normalize(p + 1e-5);

      float bandIndex = 0.0;
      float localY = 0.0;

      if (uLayerMode == 1) {
        bandIndex = 3.0; // diff
        localY = clamp(uvG.y, 0.0, 1.0);
      } else {
        // top=edge, mid=low, bottom=high
        if (uvG.y > 0.666) { bandIndex = 0.0; localY = (uvG.y - 0.666) / 0.334; }
        else if (uvG.y > 0.333) { bandIndex = 1.0; localY = (uvG.y - 0.333) / 0.333; }
        else { bandIndex = 2.0; localY = (uvG.y) / 0.333; }
        localY = clamp(localY, 0.0, 1.0);
      }

      float bandV0 = sliceV0 + bandIndex * bandH;
      float bandV1 = bandV0 + bandH;

      float yR = mix(bandV0, bandV1, clamp(uvR.y, 0.0, 1.0));
      float yG = mix(bandV0, bandV1, localY);
      float yB = mix(bandV0, bandV1, clamp(uvB.y, 0.0, 1.0));

      vec2 stR = vec2(clamp(uvR.x, 0.0, 1.0), yR);
      vec2 stG = vec2(clamp(uvG.x, 0.0, 1.0), yG);
      vec2 stB = vec2(clamp(uvB.x, 0.0, 1.0), yB);

      vec3 col;
      col.r = texture2D(uAtlas, stR).r;
      col.g = texture2D(uAtlas, stG).g;
      col.b = texture2D(uAtlas, stB).b;

      if (uColorMode == 1) {
        float lum = dot(col, vec3(0.2126,0.7152,0.0722));
        col = vec3(lum, lum*lum, pow(lum, 0.5));
      } else if (uColorMode == 2) {
        col = 1.0 - col.bgr;
      }

      if (uLayerMode == 1) {
        float lum = dot(col, vec3(0.2126,0.7152,0.0722));
        col = vec3(lum);
        col *= (0.8 + 1.6*m);
      }

      float g = hash21(gl_FragCoord.xy + t*60.0) - 0.5;
      col += g * (0.02 + 0.06*m);

      float vig = smoothstep(0.95, 0.25, r);
      col *= (0.65 + 0.55*vig);

      float fog = smoothstep(1.0, 10.0, vDepth);
      col *= (1.0 - 0.75*fog);

      col *= uGain;

      float a = mix(0.45, 0.07, depthFactor);
      a *= (0.65 + 0.55*vig);
      a *= (0.65 + 0.9*m);
      if (uLayerMode == 1) a *= 0.85;

      col = tonemap(col);
      gl_FragColor = vec4(col, a);
    }
  `
});

/* shelves group */
const shelvesGroup = new THREE.Group();
scene.add(shelvesGroup);
let shelvesEnabled = true;

function rebuildShelves(){
  while (shelvesGroup.children.length) shelvesGroup.remove(shelvesGroup.children[0]);

  baseUniforms.uAtlasSize.value.set(atlasW, atlasH);
  baseUniforms.uSliceH.value = sliceH;
  baseUniforms.uSlices.value = slices;

  const aspect = atlasW / baseSliceH;
  const w = 1.5 * aspect;
  const h = 1.5;
  const geo = new THREE.PlaneGeometry(w, h, 1, 1);

  const count = slices;
  for (let i=0; i<count; i++){
    const mFront = shelvesMat.clone();
    mFront.uniforms = THREE.UniformsUtils.clone(baseUniforms);
    mFront.uniforms.uSliceIndex.value = i;
    mFront.uniforms.uLayerMode.value = 0;

    const front = new THREE.Mesh(geo, mFront);

    const k = i / Math.max(count-1,1);
    const z = -lerp(0.2, 8.8, k);
    const bend = (k - 0.5);
    const x = 0.55 * Math.sin(bend * 2.2);
    const y = 0.12 * Math.sin(bend * 3.0);

    front.position.set(x, y, z);
    front.rotation.y = 0.25 * Math.sin(bend * 2.0);
    front.rotation.x = 0.10 * Math.sin(bend * 1.7);

    const s = lerp(1.04, 0.78, k);
    front.scale.setScalar(s);
    shelvesGroup.add(front);

    const mDiff = shelvesMat.clone();
    mDiff.uniforms = THREE.UniformsUtils.clone(baseUniforms);
    mDiff.uniforms.uSliceIndex.value = i;
    mDiff.uniforms.uLayerMode.value = 1;
    mDiff.uniforms.uGain.value = 1.35;

    const back = new THREE.Mesh(geo, mDiff);
    back.position.copy(front.position);
    back.rotation.copy(front.rotation);
    back.scale.copy(front.scale);
    back.position.z -= 0.18;
    back.scale.multiplyScalar(1.02);
    shelvesGroup.add(back);
  }
}
rebuildShelves();

/* ------------------------------
   4D Tesseract wireframe
-------------------------------- */
let tesseractEnabled = true;

function tesseractVertices4D(){
  const vs = [];
  for (let x of [-1,1])
  for (let y of [-1,1])
  for (let z of [-1,1])
  for (let w of [-1,1])
    vs.push(new THREE.Vector4(x,y,z,w));
  return vs;
}
const V4 = tesseractVertices4D();
const edges = [];
for (let i=0; i<V4.length; i++){
  for (let j=i+1; j<V4.length; j++){
    let d = 0;
    d += (V4[i].x !== V4[j].x) ? 1 : 0;
    d += (V4[i].y !== V4[j].y) ? 1 : 0;
    d += (V4[i].z !== V4[j].z) ? 1 : 0;
    d += (V4[i].w !== V4[j].w) ? 1 : 0;
    if (d === 1) edges.push([i,j]);
  }
}

const linePositions = new Float32Array(edges.length * 2 * 3);
const lineGeo = new THREE.BufferGeometry();
lineGeo.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
const lineMat = new THREE.LineBasicMaterial({ transparent:true, opacity:0.65 });
const tesseractLines = new THREE.LineSegments(lineGeo, lineMat);
tesseractLines.position.set(0, 0.1, -1.2);
scene.add(tesseractLines);

function rot4(a, b, theta, v){
  const c = Math.cos(theta), s = Math.sin(theta);
  const out = v.clone();
  const va = v.getComponent(a);
  const vb = v.getComponent(b);
  out.setComponent(a, c*va - s*vb);
  out.setComponent(b, s*va + c*vb);
  return out;
}
function project4Dto3D(v4, wDist=3.2){
  const w = v4.w;
  const k = wDist / (wDist - w);
  return new THREE.Vector3(v4.x*k, v4.y*k, v4.z*k);
}
function updateTesseract(t, m){
  const a = 0.65 + 1.65*m;
  const b = 0.35 + 1.15*m;

  const pts3 = V4.map(v=>{
    let r = v.clone();
    r = rot4(0,3, t*0.53*a, r);
    r = rot4(1,3, t*0.41*b, r);
    r = rot4(2,3, t*0.37*a, r);
    r = rot4(0,1, t*0.27, r);
    r = rot4(1,2, t*0.19, r);
    return project4Dto3D(r, 3.0 + 0.8*Math.sin(t*0.6));
  });

  let k = 0;
  for (const [i,j] of edges){
    const p = pts3[i], q = pts3[j];
    linePositions[k++] = p.x; linePositions[k++] = p.y; linePositions[k++] = p.z;
    linePositions[k++] = q.x; linePositions[k++] = q.y; linePositions[k++] = q.z;
  }
  lineGeo.attributes.position.needsUpdate = true;

  tesseractLines.scale.setScalar(0.68 + 0.35*m);
  lineMat.opacity = 0.25 + 0.55*(0.35 + m);
}

/* ------------------------------
   Dust
-------------------------------- */
let dustEnabled = true;
const dustCount = 2600;
const dustGeo = new THREE.BufferGeometry();
const dustPos = new Float32Array(dustCount*3);
const dustVel = new Float32Array(dustCount*3);

for (let i=0; i<dustCount; i++){
  dustPos[i*3+0] = (Math.random()*2-1) * 6;
  dustPos[i*3+1] = (Math.random()*2-1) * 3.5;
  dustPos[i*3+2] = -Math.random() * 10;
  dustVel[i*3+0] = (Math.random()*2-1) * 0.003;
  dustVel[i*3+1] = (Math.random()*2-1) * 0.003;
  dustVel[i*3+2] = 0.012 + Math.random()*0.01;
}
dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
const dustMat = new THREE.PointsMaterial({ size: 0.012, transparent:true, opacity:0.35 });
const dust = new THREE.Points(dustGeo, dustMat);
scene.add(dust);

function updateDust(m){
  for (let i=0; i<dustCount; i++){
    let x = dustPos[i*3+0];
    let y = dustPos[i*3+1];
    let z = dustPos[i*3+2];

    const vx = dustVel[i*3+0];
    const vy = dustVel[i*3+1];
    const vz = dustVel[i*3+2] * (0.6 + 1.8*m);

    x += vx * (0.6 + 2.2*m);
    y += vy * (0.6 + 2.2*m);
    z += vz;

    x += -x * (0.00006 + 0.00022*m);
    y += -y * (0.00006 + 0.00022*m);

    if (z > 1.8){
      z = -10 - Math.random()*5;
      x = (Math.random()*2-1) * 6;
      y = (Math.random()*2-1) * 3.5;
    }

    dustPos[i*3+0] = x;
    dustPos[i*3+1] = y;
    dustPos[i*3+2] = z;
  }
  dustGeo.attributes.position.needsUpdate = true;
  dustMat.opacity = 0.10 + 0.35*(0.35 + m);
}

/* ------------------------------
   Main insert pipeline (Flickr -> layers -> atlas -> texture)
-------------------------------- */
let running = true;
let inserting = false;
let lastMeta = '';

async function insertFromFlickr(t){
  if (inserting) return;
  inserting = true;

  // try to get a photo
  let payload = await nextPhoto();
  const octx = origC.getContext('2d', { willReadFrequently:true });

  if (payload && payload.img){
    const img = payload.img;

    // if aspect changed a lot, rebuild atlas/shelves
    const vw = img.naturalWidth || img.width || 16;
    const vh = img.naturalHeight || img.height || 9;
    const newBase = Math.round(atlasW * (vh / vw));
    if (newBase !== baseSliceH){
      resizeAtlasForAspect(vw, vh);
      rebuildShelves();
      baseUniforms.uAtlasSize.value.set(atlasW, atlasH);
      baseUniforms.uSliceH.value = sliceH;
      baseUniforms.uSlices.value = slices;
      atlasTex.needsUpdate = true;
    }

    drawImageCover(octx, img);
    lastMeta = payload.url;
    toast('Flickr inserted ✓');
  } else {
    genFallbackNoise(octx, t);
    lastMeta = '(fallback noise)';
    toast('Fallback inserted ✓');
  }

  buildLayersFromOrig(t);
  insertTopShelf();
  atlasTex.needsUpdate = true;

  // pulse for animation
  motionPulse = 1.0;

  inserting = false;
}

/* initial fill */
refillQueue();

/* ------------------------------
   Animation loop
-------------------------------- */
let last = performance.now();

function ensureFirstInsert(t){
  if (lastInsertT < -100) {
    // initialize prevC with something non-empty
    const pctx = prevC.getContext('2d', { willReadFrequently:true });
    genFallbackNoise(pctx, t);
    insertFromFlickr(t);
    lastInsertT = t;
  }
}

function animate(now){
  const t = now * 0.001;
  const dt = Math.min(0.05, (now - last) / 1000);
  last = now;

  ensureFirstInsert(t);

  if (running && (t - lastInsertT >= intervalSec)){
    insertFromFlickr(t);
    lastInsertT = t;
  }

  // synthetic motion: base + pulse decay
  motionPulse = Math.max(0, motionPulse - dt * 0.55);
  motion = clamp(0.10 + 0.65*motionPulse + 0.10*Math.sin(t*0.7), 0, 1);

  // update uniforms across shelf materials
  shelvesGroup.traverse(obj=>{
    if (obj.isMesh && obj.material && obj.material.uniforms){
      obj.material.uniforms.uTime.value = t;
      obj.material.uniforms.uMotion.value = motion;
      obj.material.uniforms.uColorMode.value = colorMode;
    }
  });

  shelvesGroup.rotation.y = 0.06 * Math.sin(t*0.4);
  shelvesGroup.rotation.x = 0.03 * Math.sin(t*0.33);
  shelvesGroup.position.y = 0.03 * Math.sin(t*0.25);

  if (tesseractEnabled) updateTesseract(t, motion);
  tesseractLines.visible = tesseractEnabled;

  if (dustEnabled) updateDust(motion);
  dust.visible = dustEnabled;

  shelvesGroup.visible = shelvesEnabled;

  scene.fog.density = 0.035 + 0.03 * motion;

  controls.update();
  renderer.render(scene, camera);

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* ------------------------------
   Resize
-------------------------------- */
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ------------------------------
   UI / Controls
-------------------------------- */
document.getElementById('apply').addEventListener('click', async ()=>{
  currentTags = document.getElementById('tags').value.trim() || 'space,nebula,night';
  toast('Loading Flickr…');
  feedQueue = [];
  await refillQueue();
});

document.getElementById('pause').addEventListener('click', ()=>{
  running = !running;
  document.getElementById('pause').textContent = running ? 'Pause' : 'Resume';
  toast(running ? 'Running' : 'Paused');
});

/* Hotkeys */
const hud = document.getElementById('hud');
addEventListener('keydown', (e)=>{
  const k = e.key.toLowerCase();
  if (k === 'h'){
    hud.style.display = (hud.style.display === 'none') ? 'block' : 'block';
    if (hud.style.display === 'none') hud.style.display = 'block';
    else hud.style.display = 'none';
    toast(hud.style.display === 'none' ? "HUD hidden" : "HUD shown");
  }
  if (k === 'f'){
    if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
    else document.exitFullscreen?.();
    toast("Fullscreen toggle");
  }
  if (k === 'm'){
    mirror = !mirror;
    toast("Mirror: " + (mirror ? "ON" : "OFF"));
  }
  if (k === 'c'){
    colorMode = (colorMode + 1) % 3;
    toast("Color mode: " + colorMode);
  }
  if (k === '['){
    slices = clamp(slices - 4, 12, 96);
    resizeAtlasForAspect(16, 9);
    rebuildShelves();
    atlasTex.needsUpdate = true;
    toast("Slices: " + slices);
  }
  if (k === ']'){
    slices = clamp(slices + 4, 12, 96);
    resizeAtlasForAspect(16, 9);
    rebuildShelves();
    atlasTex.needsUpdate = true;
    toast("Slices: " + slices);
  }
  if (k === '1'){ shelvesEnabled = !shelvesEnabled; toast("Shelves: " + (shelvesEnabled?"ON":"OFF")); }
  if (k === '2'){ tesseractEnabled = !tesseractEnabled; toast("Tesseract: " + (tesseractEnabled?"ON":"OFF")); }
  if (k === '3'){ dustEnabled = !dustEnabled; toast("Dust: " + (dustEnabled?"ON":"OFF")); }
});

/* Start: show something immediately even before Flickr returns */
(function warmStart(){
  const octx = origC.getContext('2d', { willReadFrequently:true });
  genFallbackNoise(octx, performance.now()*0.001);
  buildLayersFromOrig(performance.now()*0.001);
  insertTopShelf();
  atlasTex.needsUpdate = true;
})();
</script>
</body>
</html>
