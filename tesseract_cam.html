<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tesseract Installation — Flickr Shelves (Fixed Atlas)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; }
    #app { position:fixed; inset:0; }
    #hud{
      position:fixed; left:12px; top:12px; z-index:10;
      color:#eaeaea;
      font: 12px/1.45 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 10px 12px;
      max-width: min(900px, calc(100vw - 24px));
      backdrop-filter: blur(8px);
      user-select:none;
    }
    #hud b { color:#fff; }
    #hud .row { opacity:.92; }
    #hud .dim { opacity:.65; }
    #hud input{
      width: 260px; padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.35); color:#fff; outline:none;
      margin-left: 8px;
    }
    #hud button, #hud label{
      margin-left: 8px; padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.35); color:#fff;
      cursor:pointer;
    }
    #hud label{ display:inline-flex; align-items:center; gap:6px; }
    #hud input[type="checkbox"]{ width:auto; margin:0; transform: translateY(1px); }
    #toast{
      position:fixed; right:12px; bottom:12px; z-index:20;
      color:#fff; font: 12px ui-monospace, monospace;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 8px 10px;
      opacity:0; transform: translateY(6px);
      transition: opacity .25s ease, transform .25s ease;
      pointer-events:none;
    }
    #toast.show { opacity:1; transform: translateY(0); }
    canvas { display:block; }

    /* デバッグ：atlasを画面に出す（AキーでON/OFF） */
    #atlasPreview{
      position:fixed; right:12px; top:12px; z-index:9;
      border:1px solid rgba(255,255,255,.15);
      border-radius:12px;
      background: rgba(0,0,0,.35);
      width: 220px;
      height: auto;
      display:none;
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <canvas id="atlasPreview"></canvas>

  <div id="hud">
    <div class="row"><b>Tesseract Installation</b> — Flickr → 4s interval → layer shelves (fixed atlas)</div>
    <div class="row dim">上=輪郭 / 中=低周波(ぼかし) / 下=高周波(テクスチャ) / 背面=差分</div>

    <div class="row" style="margin-top:8px;">
      Flickr tags:
      <input id="tags" value="space,nebula,night" />
      <button id="apply">Apply</button>
      <button id="pause">Pause</button>
      <label title="画像がCORSで落ちる/直取得が無理な時はON">
        <input id="proxy" type="checkbox" checked />
        Proxy
      </label>
    </div>

    <div class="row dim" style="margin-top:6px;">
      Status: <span id="status">init…</span>
    </div>
    <div class="row dim">
      GPU maxTexture: <span id="maxTex">?</span> /
      atlasH(fixed): <span id="atlasH">?</span> /
      slices(req): <span id="reqSlices">?</span> /
      slices(used): <span id="usedSlices">?</span>
    </div>

    <div class="row dim" style="margin-top:6px;">
      Mouse: drag rotate / Wheel: zoom　
      Keys: <b>H</b> HUD <b>F</b> Fullscreen <b>M</b> Mirror <b>C</b> Color <b>[</b>/<b>]</b> slices <b>1</b> shelves <b>2</b> tesseract <b>3</b> dust <b>A</b> atlas
    </div>
  </div>

  <div id="toast"></div>

<script type="module">
import * as THREE from 'https://esm.sh/three@0.160.0';
import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';

const clamp = (x, a, b) => Math.min(b, Math.max(a, x));
const lerp  = (a, b, t) => a + (b - a) * t;

const toastEl = document.getElementById('toast');
const statusEl = document.getElementById('status');
const maxTexEl = document.getElementById('maxTex');
const atlasHEl = document.getElementById('atlasH');
const reqSlicesEl = document.getElementById('reqSlices');
const usedSlicesEl = document.getElementById('usedSlices');

function setStatus(s){ statusEl.textContent = s; }
let toastTimer = 0;
function toast(msg){
  toastEl.textContent = msg;
  toastEl.classList.add('show');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(()=> toastEl.classList.remove('show'), 1200);
}

/* offline/online guard */
window.addEventListener('offline', () => { toast('OFFLINE (DevTools Network Offline?)'); setStatus('OFFLINE'); });
window.addEventListener('online',  () => { toast('ONLINE'); });

/* ---------- Flickr JSONP ---------- */
function fetchFlickrPublicFeed(tags){
  return new Promise((resolve, reject)=>{
    const script = document.createElement('script');
    const url = new URL('https://www.flickr.com/services/feeds/photos_public.gne');
    url.searchParams.set('format', 'json');
    url.searchParams.set('tags', tags || 'space,nebula,night');
    url.searchParams.set('tagmode', 'any');

    const prev = window.jsonFlickrFeed;
    let done = false;

    const cleanup = ()=>{
      script.remove();
      if (prev) window.jsonFlickrFeed = prev;
      else try { delete window.jsonFlickrFeed; } catch {}
    };

    window.jsonFlickrFeed = (data)=>{
      if (done) return;
      done = true;
      cleanup();
      resolve(data);
    };

    script.src = url.toString();
    script.async = true;
    script.onerror = ()=>{
      if (done) return;
      done = true;
      cleanup();
      reject(new Error('Failed to load Flickr feed (script error)'));
    };
    document.head.appendChild(script);

    setTimeout(()=>{
      if (done) return;
      done = true;
      cleanup();
      reject(new Error('Flickr feed timeout'));
    }, 9000);
  });
}

/* ---------- proxy ---------- */
function proxifyWeserv(url){
  const stripped = url.replace(/^https?:\/\//,'');
  const prox = new URL('https://images.weserv.nl/');
  prox.searchParams.set('url', stripped);
  prox.searchParams.set('w', '1280');
  prox.searchParams.set('fit', 'contain');
  return prox.toString();
}
async function loadImage(url, useProxy){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.decoding = 'async';
    img.referrerPolicy = 'no-referrer';
    img.onload = ()=> resolve(img);
    img.onerror = ()=> reject(new Error('Image load failed (CORS or network)'));
    img.src = useProxy ? proxifyWeserv(url) : url;
  });
}

/* ---------- Three.js ---------- */
const app = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x000000, 1);
renderer.outputColorSpace = THREE.SRGBColorSpace;
app.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.045);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 200);
camera.position.set(0, 0.9, 3.2);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;

scene.add(new THREE.AmbientLight(0xffffff, 0.25));
const dir = new THREE.DirectionalLight(0xffffff, 0.55);
dir.position.set(2, 3, 1);
scene.add(dir);

/* ---------- Fixed Atlas (NO RESIZE EVER) ---------- */
const MAX_TEX = renderer.capabilities.maxTextureSize || 8192;
const ATLAS_H = Math.min(MAX_TEX, 8192);          // ←固定（安全側）
maxTexEl.textContent = String(MAX_TEX);
atlasHEl.textContent = String(ATLAS_H);

const atlasW = 512;
const baseSliceH = 288;                           // ←固定
const sliceH = baseSliceH * 4;                    // 4レイヤ分（edge/blur/high/diff）

let requestedSlices = 36;
let maxSlices = Math.max(4, Math.floor(ATLAS_H / sliceH));
let slices = Math.min(requestedSlices, maxSlices);

reqSlicesEl.textContent = String(requestedSlices);
usedSlicesEl.textContent = String(slices);

/* atlas canvas */
const atlas = document.createElement('canvas');
atlas.width = atlasW;
atlas.height = ATLAS_H;
const actx = atlas.getContext('2d', { willReadFrequently:true });
actx.fillStyle = '#000';
actx.fillRect(0,0,atlasW,ATLAS_H);

/* shift buffer (最大サイズ固定、コピー時に必要領域だけ使う) */
const shiftC = document.createElement('canvas');
shiftC.width = atlasW;
shiftC.height = ATLAS_H;
const shiftCtx = shiftC.getContext('2d', { willReadFrequently:true });

/* per-frame small canvases */
const origC = document.createElement('canvas');
const blurC = document.createElement('canvas');
const edgeC = document.createElement('canvas');
const highC = document.createElement('canvas');
const diffC = document.createElement('canvas');
const prevC = document.createElement('canvas');
for (const c of [origC, blurC, edgeC, highC, diffC, prevC]){
  c.width = atlasW;
  c.height = baseSliceH;
}

/* preview (optional) */
const atlasPreview = document.getElementById('atlasPreview');
atlasPreview.width = atlasW;
atlasPreview.height = ATLAS_H;
const pctx = atlasPreview.getContext('2d', { willReadFrequently:true });
let atlasPreviewOn = false;

function updateAtlasPreview(){
  if (!atlasPreviewOn) return;
  pctx.clearRect(0,0,atlasW,ATLAS_H);
  pctx.drawImage(atlas, 0, 0);
}

function usedHeight(){
  return sliceH * slices;
}

/* texture (size fixed) */
const atlasTex = new THREE.CanvasTexture(atlas);
atlasTex.minFilter = THREE.LinearFilter;
atlasTex.magFilter = THREE.LinearFilter;
atlasTex.wrapS = THREE.ClampToEdgeWrapping;
atlasTex.wrapT = THREE.ClampToEdgeWrapping;
atlasTex.colorSpace = THREE.SRGBColorSpace;

/* ---------- drawing helpers ---------- */
let mirror = true;

function drawImageCover(ctx, img){
  const cw = atlasW, ch = baseSliceH;
  const iw = img.naturalWidth || img.width || 1;
  const ih = img.naturalHeight || img.height || 1;

  const scale = Math.max(cw / iw, ch / ih);
  const sw = cw / scale;
  const sh = ch / scale;
  const sx = (iw - sw) * 0.5;
  const sy = (ih - sh) * 0.5;

  ctx.save();
  ctx.clearRect(0,0,cw,ch);
  if (mirror){
    ctx.translate(cw, 0);
    ctx.scale(-1, 1);
  }
  ctx.drawImage(img, sx, sy, sw, sh, 0, 0, cw, ch);
  ctx.restore();
}

function genFallbackNoise(ctx, t){
  const img = ctx.createImageData(atlasW, baseSliceH);
  for (let i=0; i<img.data.length; i+=4){
    const x = ((i/4) % atlasW) / atlasW;
    const y = Math.floor((i/4) / atlasW) / baseSliceH;
    const v = (Math.sin(20*x + 7*y + t*2) + Math.sin(13*x - 11*y + t*1.3)) * 0.5;
    const n = (v*0.5+0.5) * 255;
    img.data[i+0] = n;
    img.data[i+1] = n*0.8;
    img.data[i+2] = n*0.6;
    img.data[i+3] = 255;
  }
  ctx.putImageData(img, 0, 0);
}

function buildLayersFromOrig(){
  const bctx = blurC.getContext('2d', { willReadFrequently:true });
  const ectx = edgeC.getContext('2d', { willReadFrequently:true });
  const hctx = highC.getContext('2d', { willReadFrequently:true });
  const dctx = diffC.getContext('2d', { willReadFrequently:true });
  const pctx2 = prevC.getContext('2d', { willReadFrequently:true });

  bctx.save();
  bctx.clearRect(0,0,atlasW,baseSliceH);
  bctx.filter = 'blur(12px)';
  bctx.drawImage(origC, 0, 0);
  bctx.restore();

  ectx.save();
  ectx.clearRect(0,0,atlasW,baseSliceH);
  ectx.filter = 'contrast(280%)';
  ectx.globalCompositeOperation = 'source-over';
  ectx.drawImage(origC, 0, 0);
  ectx.globalCompositeOperation = 'difference';
  ectx.drawImage(origC, 1, 0);
  ectx.drawImage(origC, 0, 1);
  ectx.globalCompositeOperation = 'source-over';
  ectx.restore();

  hctx.save();
  hctx.clearRect(0,0,atlasW,baseSliceH);
  hctx.filter = 'contrast(190%) brightness(110%)';
  hctx.fillStyle = 'rgb(128,128,128)';
  hctx.fillRect(0,0,atlasW,baseSliceH);
  hctx.globalCompositeOperation = 'difference';
  hctx.drawImage(blurC, 0, 0);
  hctx.globalCompositeOperation = 'difference';
  hctx.drawImage(origC, 0, 0);
  hctx.globalCompositeOperation = 'source-over';
  hctx.restore();

  dctx.save();
  dctx.clearRect(0,0,atlasW,baseSliceH);
  dctx.filter = 'contrast(320%)';
  dctx.globalCompositeOperation = 'source-over';
  dctx.drawImage(origC, 0, 0);
  dctx.globalCompositeOperation = 'difference';
  dctx.drawImage(prevC, 0, 0);
  dctx.globalCompositeOperation = 'source-over';
  dctx.restore();

  pctx2.clearRect(0,0,atlasW,baseSliceH);
  pctx2.drawImage(origC, 0, 0);
}

/* 使っている領域(usedH)内だけをシフトし、トップに新段を挿入 */
function insertTopShelf(){
  const usedH = usedHeight();
  const copyH = usedH - sliceH;

  if (copyH > 0){
    shiftCtx.clearRect(0,0,atlasW,copyH);
    shiftCtx.drawImage(atlas, 0, 0, atlasW, copyH, 0, 0, atlasW, copyH);
    actx.drawImage(shiftC, 0, 0, atlasW, copyH, 0, sliceH, atlasW, copyH);
  }

  // トップ段を描画
  actx.drawImage(edgeC, 0, 0, atlasW, baseSliceH, 0, 0*baseSliceH, atlasW, baseSliceH);
  actx.drawImage(blurC, 0, 0, atlasW, baseSliceH, 0, 1*baseSliceH, atlasW, baseSliceH);
  actx.drawImage(highC, 0, 0, atlasW, baseSliceH, 0, 2*baseSliceH, atlasW, baseSliceH);
  actx.drawImage(diffC, 0, 0, atlasW, baseSliceH, 0, 3*baseSliceH, atlasW, baseSliceH);

  // 使っていない領域は薄く暗く保つ（見た目を安定）
  actx.fillStyle = 'rgba(0,0,0,0.02)';
  actx.fillRect(0, usedH, atlasW, ATLAS_H - usedH);

  // トップも軽く減衰
  actx.fillStyle = 'rgba(0,0,0,0.03)';
  actx.fillRect(0,0,atlasW,sliceH);
}

/* ---------- Visual controls ---------- */
let colorMode = 0;
let motion = 0.12;
let motionPulse = 0.0;

/* ---------- Shader (pixel-based y mapping) ---------- */
const baseUniforms = {
  uAtlas: { value: atlasTex },
  uAtlasH: { value: ATLAS_H },
  uSliceH: { value: sliceH },
  uSlices: { value: slices },
  uTime: { value: 0 },
  uSliceIndex: { value: 0 },
  uMotion: { value: 0 },
  uColorMode: { value: colorMode },
  uGain: { value: 1.15 },
  uLayerMode: { value: 0 }
};

const shelvesMat = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  uniforms: baseUniforms,
  vertexShader: `
    varying vec2 vUv;
    varying float vDepth;
    void main(){
      vUv = uv;
      vec4 mv = modelViewMatrix * vec4(position, 1.0);
      vDepth = -mv.z;
      gl_Position = projectionMatrix * mv;
    }
  `,
  fragmentShader: `
    precision highp float;
    varying vec2 vUv;
    varying float vDepth;

    uniform sampler2D uAtlas;
    uniform float uAtlasH;
    uniform float uSliceH;
    uniform float uSlices;
    uniform float uTime;
    uniform float uSliceIndex;
    uniform float uMotion;
    uniform int uColorMode;
    uniform float uGain;
    uniform int uLayerMode;

    float hash21(vec2 p){
      p = fract(p*vec2(123.34, 345.45));
      p += dot(p, p+34.345);
      return fract(p.x*p.y);
    }
    vec3 tonemap(vec3 c){
      c = max(c, 0.0);
      c = c / (1.0 + c);
      return pow(c, vec3(0.95));
    }

    void main(){
      float m = uMotion;
      float t = uTime;

      vec2 uv = vUv;
      vec2 p  = uv - 0.5;
      float r = length(p);

      float depthFactor = clamp((uSliceIndex / max(uSlices-1.0, 1.0)), 0.0, 1.0);

      float lens = (0.10 + 0.32*m) * (0.35 + depthFactor);
      p *= (1.0 + lens * r*r);

      float swirl = (0.18 + 0.62*m) * (0.25 + depthFactor);
      float ang = swirl * sin(t*0.7 + depthFactor*6.283 + p.x*2.0 - p.y*2.0);
      float cs = cos(ang), sn = sin(ang);
      p = mat2(cs, -sn, sn, cs) * p;

      float ca = (0.002 + 0.01*m) * (0.35 + r);
      vec2 uvR = p + 0.5 + ca * normalize(p + 1e-5);
      vec2 uvG = p + 0.5;
      vec2 uvB = p + 0.5 - ca * normalize(p + 1e-5);

      float bandIndex = 0.0;
      float localY = 0.0;

      if (uLayerMode == 1) {
        bandIndex = 3.0;
        localY = clamp(uvG.y, 0.0, 1.0);
      } else {
        if (uvG.y > 0.666) { bandIndex = 0.0; localY = (uvG.y - 0.666) / 0.334; }
        else if (uvG.y > 0.333) { bandIndex = 1.0; localY = (uvG.y - 0.333) / 0.333; }
        else { bandIndex = 2.0; localY = (uvG.y) / 0.333; }
        localY = clamp(localY, 0.0, 1.0);
      }

      float bandHpx   = uSliceH * 0.25;
      float sliceV0px = uSliceIndex * uSliceH;
      float bandV0px  = sliceV0px + bandIndex * bandHpx;

      float yR = (bandV0px + clamp(uvR.y,0.0,1.0)*bandHpx) / uAtlasH;
      float yG = (bandV0px + localY*bandHpx) / uAtlasH;
      float yB = (bandV0px + clamp(uvB.y,0.0,1.0)*bandHpx) / uAtlasH;

      vec2 stR = vec2(clamp(uvR.x, 0.0, 1.0), yR);
      vec2 stG = vec2(clamp(uvG.x, 0.0, 1.0), yG);
      vec2 stB = vec2(clamp(uvB.x, 0.0, 1.0), yB);

      vec3 col;
      col.r = texture2D(uAtlas, stR).r;
      col.g = texture2D(uAtlas, stG).g;
      col.b = texture2D(uAtlas, stB).b;

      if (uColorMode == 1) {
        float lum = dot(col, vec3(0.2126,0.7152,0.0722));
        col = vec3(lum, lum*lum, pow(lum, 0.5));
      } else if (uColorMode == 2) {
        col = 1.0 - col.bgr;
      }

      if (uLayerMode == 1) {
        float lum = dot(col, vec3(0.2126,0.7152,0.0722));
        col = vec3(lum);
        col *= (0.8 + 1.6*m);
      }

      float g = hash21(gl_FragCoord.xy + t*60.0) - 0.5;
      col += g * (0.02 + 0.06*m);

      float vig = smoothstep(0.95, 0.25, r);
      col *= (0.65 + 0.55*vig);

      float fog = smoothstep(1.0, 10.0, vDepth);
      col *= (1.0 - 0.75*fog);

      col *= uGain;

      float a = mix(0.45, 0.07, depthFactor);
      a *= (0.65 + 0.55*vig);
      a *= (0.65 + 0.9*m);
      if (uLayerMode == 1) a *= 0.85;

      col = tonemap(col);
      gl_FragColor = vec4(col, a);
    }
  `
});

shelvesMat.blending = THREE.AdditiveBlending;
shelvesMat.side = THREE.DoubleSide;

/* ---------- Shelves ---------- */
const shelvesGroup = new THREE.Group();
scene.add(shelvesGroup);
let shelvesEnabled = true;

function rebuildShelves(){
  while (shelvesGroup.children.length) shelvesGroup.remove(shelvesGroup.children[0]);

  baseUniforms.uSlices.value = slices;

  const aspect = atlasW / baseSliceH;
  const w = 1.5 * aspect;
  const h = 1.5;
  const geo = new THREE.PlaneGeometry(w, h, 1, 1);

  const count = slices;
  for (let i=0; i<count; i++){
    const mFront = shelvesMat.clone();
    mFront.uniforms = THREE.UniformsUtils.clone(baseUniforms);
    mFront.uniforms.uSliceIndex.value = i;
    mFront.uniforms.uLayerMode.value = 0;

    const front = new THREE.Mesh(geo, mFront);

    const k = i / Math.max(count-1,1);
    const z = -lerp(0.2, 8.8, k);
    const bend = (k - 0.5);
    front.position.set(
      0.55 * Math.sin(bend * 2.2),
      0.12 * Math.sin(bend * 3.0),
      z
    );
    front.rotation.y = 0.25 * Math.sin(bend * 2.0);
    front.rotation.x = 0.10 * Math.sin(bend * 1.7);
    front.scale.setScalar(lerp(1.04, 0.78, k));
    shelvesGroup.add(front);

    const mDiff = shelvesMat.clone();
    mDiff.uniforms = THREE.UniformsUtils.clone(baseUniforms);
    mDiff.uniforms.uSliceIndex.value = i;
    mDiff.uniforms.uLayerMode.value = 1;
    mDiff.uniforms.uGain.value = 1.35;

    const back = new THREE.Mesh(geo, mDiff);
    back.position.copy(front.position);
    back.rotation.copy(front.rotation);
    back.scale.copy(front.scale);
    back.position.z -= 0.18;
    back.scale.multiplyScalar(1.02);
    shelvesGroup.add(back);
  }
}

/* ---------- Tesseract ---------- */
let tesseractEnabled = true;
function tesseractVertices4D(){
  const vs = [];
  for (let x of [-1,1])
  for (let y of [-1,1])
  for (let z of [-1,1])
  for (let w of [-1,1]) vs.push(new THREE.Vector4(x,y,z,w));
  return vs;
}
const V4 = tesseractVertices4D();
const edges = [];
for (let i=0; i<V4.length; i++){
  for (let j=i+1; j<V4.length; j++){
    let d = 0;
    d += (V4[i].x !== V4[j].x) ? 1 : 0;
    d += (V4[i].y !== V4[j].y) ? 1 : 0;
    d += (V4[i].z !== V4[j].z) ? 1 : 0;
    d += (V4[i].w !== V4[j].w) ? 1 : 0;
    if (d === 1) edges.push([i,j]);
  }
}
const linePositions = new Float32Array(edges.length * 2 * 3);
const lineGeo = new THREE.BufferGeometry();
lineGeo.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
const lineMat = new THREE.LineBasicMaterial({ transparent:true, opacity:0.65 });
const tesseractLines = new THREE.LineSegments(lineGeo, lineMat);
tesseractLines.position.set(0, 0.1, -1.2);
scene.add(tesseractLines);

function rot4(a, b, theta, v){
  const c = Math.cos(theta), s = Math.sin(theta);
  const out = v.clone();
  const va = v.getComponent(a);
  const vb = v.getComponent(b);
  out.setComponent(a, c*va - s*vb);
  out.setComponent(b, s*va + c*vb);
  return out;
}
function project4Dto3D(v4, wDist=3.2){
  const w = v4.w;
  const k = wDist / (wDist - w);
  return new THREE.Vector3(v4.x*k, v4.y*k, v4.z*k);
}
function updateTesseract(t, m){
  const a = 0.65 + 1.65*m;
  const b = 0.35 + 1.15*m;
  const pts3 = V4.map(v=>{
    let r = v.clone();
    r = rot4(0,3, t*0.53*a, r);
    r = rot4(1,3, t*0.41*b, r);
    r = rot4(2,3, t*0.37*a, r);
    r = rot4(0,1, t*0.27, r);
    r = rot4(1,2, t*0.19, r);
    return project4Dto3D(r, 3.0 + 0.8*Math.sin(t*0.6));
  });
  let k = 0;
  for (const [i,j] of edges){
    const p = pts3[i], q = pts3[j];
    linePositions[k++] = p.x; linePositions[k++] = p.y; linePositions[k++] = p.z;
    linePositions[k++] = q.x; linePositions[k++] = q.y; linePositions[k++] = q.z;
  }
  lineGeo.attributes.position.needsUpdate = true;
  tesseractLines.scale.setScalar(0.68 + 0.35*m);
  lineMat.opacity = 0.25 + 0.55*(0.35 + m);
}

/* ---------- Dust ---------- */
let dustEnabled = true;
const dustCount = 1800;
const dustGeo = new THREE.BufferGeometry();
const dustPos = new Float32Array(dustCount*3);
const dustVel = new Float32Array(dustCount*3);
for (let i=0; i<dustCount; i++){
  dustPos[i*3+0] = (Math.random()*2-1) * 6;
  dustPos[i*3+1] = (Math.random()*2-1) * 3.5;
  dustPos[i*3+2] = -Math.random() * 10;
  dustVel[i*3+0] = (Math.random()*2-1) * 0.003;
  dustVel[i*3+1] = (Math.random()*2-1) * 0.003;
  dustVel[i*3+2] = 0.012 + Math.random()*0.01;
}
dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
const dustMat = new THREE.PointsMaterial({ size: 0.012, transparent:true, opacity:0.35 });
const dust = new THREE.Points(dustGeo, dustMat);
scene.add(dust);

function updateDust(m){
  for (let i=0; i<dustCount; i++){
    let x = dustPos[i*3+0], y = dustPos[i*3+1], z = dustPos[i*3+2];
    const vx = dustVel[i*3+0];
    const vy = dustVel[i*3+1];
    const vz = dustVel[i*3+2] * (0.6 + 1.8*m);
    x += vx * (0.6 + 2.2*m);
    y += vy * (0.6 + 2.2*m);
    z += vz;
    x += -x * (0.00006 + 0.00022*m);
    y += -y * (0.00006 + 0.00022*m);
    if (z > 1.8){
      z = -10 - Math.random()*5;
      x = (Math.random()*2-1) * 6;
      y = (Math.random()*2-1) * 3.5;
    }
    dustPos[i*3+0] = x; dustPos[i*3+1] = y; dustPos[i*3+2] = z;
  }
  dustGeo.attributes.position.needsUpdate = true;
  dustMat.opacity = 0.10 + 0.35*(0.35 + m);
}

/* ---------- Feed ---------- */
let currentTags = document.getElementById('tags').value.trim();
let feedQueue = [];
let inFlightFetch = false;
let stats = { inserted:0, loaded:0, failed:0, noise:0 };

async function refillQueue(){
  if (inFlightFetch) return;
  inFlightFetch = true;
  setStatus('fetching feed…');
  try{
    const data = await fetchFlickrPublicFeed(currentTags);
    const urls = (data?.items || []).map(it => it?.media?.m).filter(Boolean);
    for (let i = urls.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [urls[i], urls[j]] = [urls[j], urls[i]];
    }
    feedQueue = urls;
    toast(`Flickr feed: ${feedQueue.length} items`);
  }catch(e){
    console.error(e);
    toast('Flickr feed failed (fallback continues)');
    feedQueue = [];
  }finally{
    inFlightFetch = false;
    setStatus(`queue:${feedQueue.length} | inserted:${stats.inserted} loaded:${stats.loaded} failed:${stats.failed} noise:${stats.noise}`);
  }
}

async function nextPhoto(useProxy){
  if (feedQueue.length < 6) refillQueue();
  const url = feedQueue.shift();
  if (!url) return null;
  try{
    const img = await loadImage(url, useProxy);
    stats.loaded++;
    return { img, url };
  }catch(e){
    stats.failed++;
    console.warn('Image failed:', url, e);
    return null;
  }
}

/* ---------- Insert ---------- */
let intervalSec = 4.0;
let lastInsertT = -999;
let running = true;
let inserting = false;

async function insertFromFlickr(t){
  if (inserting) return;
  inserting = true;

  const useProxy = document.getElementById('proxy').checked;
  const octx = origC.getContext('2d', { willReadFrequently:true });

  let payload = null;
  for (let tries=0; tries<6; tries++){
    payload = await nextPhoto(useProxy);
    if (payload && payload.img) break;
  }

  if (payload && payload.img){
    drawImageCover(octx, payload.img);
    stats.inserted++;
    toast('Flickr inserted ✓');
  } else {
    genFallbackNoise(octx, t);
    stats.noise++;
    stats.inserted++;
    toast('Fallback inserted ✓');
  }

  buildLayersFromOrig();
  insertTopShelf();

  atlasTex.needsUpdate = true;
  updateAtlasPreview();

  motionPulse = 1.0;
  setStatus(`queue:${feedQueue.length} | inserted:${stats.inserted} loaded:${stats.loaded} failed:${stats.failed} noise:${stats.noise}`);
  inserting = false;
}

/* ---------- start ---------- */
rebuildShelves();

/* warm start */
{
  const t = performance.now()*0.001;
  const pctx2 = prevC.getContext('2d', { willReadFrequently:true });
  genFallbackNoise(pctx2, t);
  const octx = origC.getContext('2d', { willReadFrequently:true });
  genFallbackNoise(octx, t);
  buildLayersFromOrig();
  insertTopShelf();
  atlasTex.needsUpdate = true;
  updateAtlasPreview();
}

refillQueue();

/* ---------- loop ---------- */
let last = performance.now();
function animate(now){
  const t = now * 0.001;
  const dt = Math.min(0.05, (now - last) / 1000);
  last = now;

  if (lastInsertT < -100){
    insertFromFlickr(t);
    lastInsertT = t;
  }
  if (running && (t - lastInsertT >= intervalSec)){
    insertFromFlickr(t);
    lastInsertT = t;
  }

  motionPulse = Math.max(0, motionPulse - dt * 0.55);
  motion = clamp(0.10 + 0.65*motionPulse + 0.10*Math.sin(t*0.7), 0, 1);

  shelvesGroup.traverse(obj=>{
    if (obj.isMesh && obj.material && obj.material.uniforms){
      obj.material.uniforms.uTime.value = t;
      obj.material.uniforms.uMotion.value = motion;
      obj.material.uniforms.uColorMode.value = colorMode;
      obj.material.uniforms.uSlices.value = slices;
    }
  });

  shelvesGroup.rotation.y = 0.06 * Math.sin(t*0.4);
  shelvesGroup.rotation.x = 0.03 * Math.sin(t*0.33);
  shelvesGroup.position.y = 0.03 * Math.sin(t*0.25);

  if (tesseractEnabled) updateTesseract(t, motion);
  tesseractLines.visible = tesseractEnabled;

  if (dustEnabled) updateDust(motion);
  dust.visible = dustEnabled;

  shelvesGroup.visible = shelvesEnabled;

  scene.fog.density = 0.035 + 0.03 * motion;

  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* ---------- UI ---------- */
document.getElementById('apply').addEventListener('click', async ()=>{
  currentTags = document.getElementById('tags').value.trim() || 'space,nebula,night';
  feedQueue = [];
  toast('Loading Flickr…');
  await refillQueue();
});

document.getElementById('pause').addEventListener('click', ()=>{
  running = !running;
  document.getElementById('pause').textContent = running ? 'Pause' : 'Resume';
  toast(running ? 'Running' : 'Paused');
});

addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

const hud = document.getElementById('hud');
addEventListener('keydown', (e)=>{
  const k = e.key.toLowerCase();
  if (k === 'h'){
    hud.style.display = (hud.style.display === 'none') ? 'block' : 'none';
    toast(hud.style.display === 'none' ? "HUD hidden" : "HUD shown");
  }
  if (k === 'f'){
    if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
    else document.exitFullscreen?.();
    toast("Fullscreen toggle");
  }
  if (k === 'm'){
    mirror = !mirror;
    toast("Mirror: " + (mirror ? "ON" : "OFF"));
  }
  if (k === 'c'){
    colorMode = (colorMode + 1) % 3;
    toast("Color mode: " + colorMode);
  }
  if (k === 'a'){
    atlasPreviewOn = !atlasPreviewOn;
    atlasPreview.style.display = atlasPreviewOn ? 'block' : 'none';
    updateAtlasPreview();
    toast("Atlas preview: " + (atlasPreviewOn ? "ON" : "OFF"));
  }

  if (k === '['){
    requestedSlices = clamp(requestedSlices - 4, 8, 96);
    maxSlices = Math.max(4, Math.floor(ATLAS_H / sliceH));
    slices = Math.min(requestedSlices, maxSlices);
    baseUniforms.uSlices.value = slices;
    reqSlicesEl.textContent = String(requestedSlices);
    usedSlicesEl.textContent = String(slices);
    rebuildShelves();
    toast(`Slices requested:${requestedSlices} used:${slices}`);
  }
  if (k === ']'){
    requestedSlices = clamp(requestedSlices + 4, 8, 96);
    maxSlices = Math.max(4, Math.floor(ATLAS_H / sliceH));
    slices = Math.min(requestedSlices, maxSlices);
    baseUniforms.uSlices.value = slices;
    reqSlicesEl.textContent = String(requestedSlices);
    usedSlicesEl.textContent = String(slices);
    rebuildShelves();
    toast(`Slices requested:${requestedSlices} used:${slices}`);
  }

  if (k === '1'){ shelvesEnabled = !shelvesEnabled; toast("Shelves: " + (shelvesEnabled?"ON":"OFF")); }
  if (k === '2'){ tesseractEnabled = !tesseractEnabled; toast("Tesseract: " + (tesseractEnabled?"ON":"OFF")); }
  if (k === '3'){ dustEnabled = !dustEnabled; toast("Dust: " + (dustEnabled?"ON":"OFF")); }
});
</script>
</body>
</html>
