<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tesseract Camera Installation — 4s Capture + Layer Shelves</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; }
    #app { position:fixed; inset:0; }
    #hud {
      position:fixed; left:12px; top:12px; color:#eaeaea;
      font: 12px/1.45 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 10px 12px;
      max-width: min(560px, calc(100vw - 24px));
      backdrop-filter: blur(8px);
      user-select:none;
    }
    #hud b { color:#fff; }
    #hud .row { opacity:.92; }
    #hud .dim { opacity:.65; }
    #toast {
      position:fixed; right:12px; bottom:12px;
      color:#fff; font: 12px ui-monospace, monospace;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 8px 10px;
      opacity:0; transform: translateY(6px);
      transition: opacity .25s ease, transform .25s ease;
      pointer-events:none;
    }
    #toast.show { opacity:1; transform: translateY(0); }
    canvas { display:block; }
  </style>

  <!-- GitHub Pages / bare import 対策 -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="app"></div>
  <div id="hud">
    <div class="row"><b>Tesseract Camera Installation</b> — 4s capture → layer-decomposed shelves</div>
    <div class="row dim">棚（前面）：上=輪郭 / 中=低周波(ぼかし) / 下=高周波(テクスチャ)</div>
    <div class="row dim">棚（背面）：動いた部分だけ（差分マスク）</div>
    <div class="row">Mouse: ドラッグ回転 / Wheel: ズーム</div>
    <div class="row">Keys:
      <b>H</b> HUD,
      <b>F</b> Fullscreen,
      <b>M</b> Mirror,
      <b>C</b> Color mode,
      <b>[</b>/<b>]</b> slices,
      <b>1</b> shelves,
      <b>2</b> tesseract,
      <b>3</b> dust
    </div>
  </div>
  <div id="toast"></div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

const clamp = (x, a, b) => Math.min(b, Math.max(a, x));
const lerp  = (a, b, t) => a + (b - a) * t;

const toastEl = document.getElementById('toast');
let toastTimer = 0;
function toast(msg){
  toastEl.textContent = msg;
  toastEl.classList.add('show');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(()=> toastEl.classList.remove('show'), 1200);
}

/* ------------------------------
   Webcam
-------------------------------- */
const video = document.createElement('video');
video.autoplay = true;
video.playsInline = true;
video.muted = true;

let mirror = true;
let camReady = false;

async function initCamera(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user", width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false
    });
    video.srcObject = stream;
    await video.play();
    camReady = true;
    toast("Camera connected");
  }catch(err){
    console.error(err);
    camReady = false;
    toast("Camera blocked — using fallback noise");
  }
}
await initCamera();

/* ------------------------------
   Atlas: time-shelves, but each time-shelf contains 4 bands:
   [0] edge, [1] low-pass, [2] high-pass, [3] diff-mask
   We capture every 4 seconds (not every frame).
-------------------------------- */
let slices = 36;               // how many captures stored
let captureInterval = 4.0;     // seconds
let lastCaptureT = -999;

let atlasW = 640;
let baseSliceH = 360;          // height of one band (one processed layer)
let sliceH = baseSliceH * 4;   // one time-shelf contains 4 bands stacked
let atlasH = sliceH * slices;

const atlas = document.createElement('canvas');
const actx = atlas.getContext('2d', { willReadFrequently: true });

function resizeAtlasFromVideo(){
  const vw = Math.max(2, video.videoWidth || 1280);
  const vh = Math.max(2, video.videoHeight || 720);

  atlasW = 640;
  baseSliceH = Math.round(atlasW * (vh / vw));
  sliceH = baseSliceH * 4;
  atlasH = sliceH * slices;

  atlas.width = atlasW;
  atlas.height = atlasH;

  actx.fillStyle = "#000";
  actx.fillRect(0,0,atlasW,atlasH);
}

if (camReady) {
  if (video.readyState >= 1) resizeAtlasFromVideo();
  else video.addEventListener('loadedmetadata', () => resizeAtlasFromVideo(), { once:true });
} else {
  resizeAtlasFromVideo();
}

/* temp canvases for processing */
const origC = document.createElement('canvas');
const blurC = document.createElement('canvas');
const edgeC = document.createElement('canvas');
const highC = document.createElement('canvas');
const diffC = document.createElement('canvas');

function syncTempCanvases(){
  for (const c of [origC, blurC, edgeC, highC, diffC]){
    c.width = atlasW;
    c.height = baseSliceH;
  }
}
syncTempCanvases();

let prevCaptureLum = null; // Float32Array(atlasW*baseSliceH) luminance of previous capture

function drawVideoTo(ctx){
  ctx.save();
  ctx.clearRect(0,0,atlasW,baseSliceH);
  if (mirror){
    ctx.translate(atlasW, 0);
    ctx.scale(-1, 1);
  }
  ctx.drawImage(video, 0, 0, atlasW, baseSliceH);
  ctx.restore();
}

function genFallbackNoise(ctx, t){
  const img = ctx.createImageData(atlasW, baseSliceH);
  for (let i=0; i<img.data.length; i+=4){
    const x = ((i/4) % atlasW) / atlasW;
    const y = Math.floor((i/4) / atlasW) / baseSliceH;
    const v = (Math.sin(20*x + 7*y + t*2) + Math.sin(13*x - 11*y + t*1.3)) * 0.5;
    const n = (v*0.5+0.5) * 255;
    img.data[i+0] = n;
    img.data[i+1] = n*0.8;
    img.data[i+2] = n*0.6;
    img.data[i+3] = 255;
  }
  ctx.putImageData(img, 0, 0);
}

function computeLuminanceArray(imgData){
  const d = imgData.data;
  const lum = new Float32Array(atlasW * baseSliceH);
  for (let i=0, p=0; i<d.length; i+=4, p++){
    const r = d[i], g = d[i+1], b = d[i+2];
    lum[p] = 0.2126*r + 0.7152*g + 0.0722*b;
  }
  return lum;
}

// simple Sobel edge on luminance (every 4 secなので重くてもOK)
function sobelEdgeFromLum(lum){
  const out = new Uint8ClampedArray(atlasW * baseSliceH * 4);
  const w = atlasW, h = baseSliceH;

  for (let y=1; y<h-1; y++){
    for (let x=1; x<w-1; x++){
      const i = y*w + x;

      const tl = lum[(y-1)*w + (x-1)];
      const tc = lum[(y-1)*w + (x)];
      const tr = lum[(y-1)*w + (x+1)];
      const ml = lum[(y)*w + (x-1)];
      const mr = lum[(y)*w + (x+1)];
      const bl = lum[(y+1)*w + (x-1)];
      const bc = lum[(y+1)*w + (x)];
      const br = lum[(y+1)*w + (x+1)];

      const gx = (-1*tl) + (1*tr) + (-2*ml) + (2*mr) + (-1*bl) + (1*br);
      const gy = (-1*tl) + (-2*tc) + (-1*tr) + (1*bl) + (2*bc) + (1*br);

      let g = Math.sqrt(gx*gx + gy*gy);
      // boost + clamp
      g = clamp(g * 0.9, 0, 255);

      const o = i*4;
      out[o+0] = g;
      out[o+1] = g;
      out[o+2] = g;
      out[o+3] = 255;
    }
  }
  return out;
}

function captureAndInsert(t){
  // shift old shelves down by one shelf (sliceH)
  actx.drawImage(atlas, 0, 0, atlasW, atlasH - sliceH, 0, sliceH, atlasW, atlasH - sliceH);

  // produce orig
  const octx = origC.getContext('2d', { willReadFrequently:true });
  const bctx = blurC.getContext('2d', { willReadFrequently:true });
  const ectx = edgeC.getContext('2d', { willReadFrequently:true });
  const hctx = highC.getContext('2d', { willReadFrequently:true });
  const dctx = diffC.getContext('2d', { willReadFrequently:true });

  if (camReady && video.videoWidth > 0) {
    drawVideoTo(octx);

    // low-pass blur
    bctx.save();
    bctx.clearRect(0,0,atlasW,baseSliceH);
    bctx.filter = 'blur(10px)';
    // blur input: draw original canvas to preserve mirror already applied
    bctx.drawImage(origC, 0, 0);
    bctx.restore();
  } else {
    genFallbackNoise(octx, t);
    bctx.drawImage(origC, 0, 0);
  }

  // read orig & blur for high-pass + diff
  const origImg = octx.getImageData(0,0,atlasW,baseSliceH);
  const blurImg = bctx.getImageData(0,0,atlasW,baseSliceH);

  const lum = computeLuminanceArray(origImg);

  // edge
  const edgeRGBA = sobelEdgeFromLum(lum);
  const edgeImg = new ImageData(edgeRGBA, atlasW, baseSliceH);
  ectx.putImageData(edgeImg, 0, 0);

  // high-pass (orig - blur) * 2 + 128
  const hi = hctx.createImageData(atlasW, baseSliceH);
  const od = origImg.data;
  const bd = blurImg.data;
  const hd = hi.data;
  for (let i=0; i<od.length; i+=4){
    const r = (od[i]   - bd[i])   * 2 + 128;
    const g = (od[i+1] - bd[i+1]) * 2 + 128;
    const b = (od[i+2] - bd[i+2]) * 2 + 128;
    hd[i]   = clamp(r, 0, 255);
    hd[i+1] = clamp(g, 0, 255);
    hd[i+2] = clamp(b, 0, 255);
    hd[i+3] = 255;
  }
  hctx.putImageData(hi, 0, 0);

  // diff mask vs previous capture luminance
  const di = dctx.createImageData(atlasW, baseSliceH);
  const dd = di.data;
  if (!prevCaptureLum) prevCaptureLum = new Float32Array(lum.length);

  for (let p=0, i=0; p<lum.length; p++, i+=4){
    const diff = Math.abs(lum[p] - prevCaptureLum[p]);
    // threshold + boost
    let v = (diff - 12.0) * 5.0; // adjust sensitivity
    v = clamp(v, 0, 255);
    dd[i] = v; dd[i+1] = v; dd[i+2] = v; dd[i+3] = 255;
    prevCaptureLum[p] = lum[p];
  }
  dctx.putImageData(di, 0, 0);

  // write bands into atlas top shelf (y=0..sliceH)
  // band order: 0=edge, 1=low(blur), 2=high, 3=diff
  actx.drawImage(edgeC, 0, 0, atlasW, baseSliceH, 0, 0*baseSliceH, atlasW, baseSliceH);
  actx.drawImage(blurC, 0, 0, atlasW, baseSliceH, 0, 1*baseSliceH, atlasW, baseSliceH);
  actx.drawImage(highC, 0, 0, atlasW, baseSliceH, 0, 2*baseSliceH, atlasW, baseSliceH);
  actx.drawImage(diffC, 0, 0, atlasW, baseSliceH, 0, 3*baseSliceH, atlasW, baseSliceH);

  // slight fade to keep it “install-y”
  actx.fillStyle = "rgba(0,0,0,0.03)";
  actx.fillRect(0,0,atlasW,sliceH);

  toast("Captured (layer-split) ✓");
}

/* ------------------------------
   Motion detection (for interactivity, still per frame)
-------------------------------- */
const mW = 96, mH = 54;
const motionCanvas = document.createElement('canvas');
motionCanvas.width = mW; motionCanvas.height = mH;
const mctx = motionCanvas.getContext('2d', { willReadFrequently: true });
let prevMotionFrame = null;
let motion = 0;
let motionRaw = 0;

function updateMotion(){
  if (!(camReady && video.videoWidth > 0)) {
    motionRaw = 0.15 * (Math.sin(performance.now()*0.001) * 0.5 + 0.5);
    motion = lerp(motion, motionRaw, 0.05);
    return;
  }
  mctx.save();
  mctx.clearRect(0,0,mW,mH);
  if (mirror){
    mctx.translate(mW,0);
    mctx.scale(-1,1);
  }
  mctx.drawImage(video, 0, 0, mW, mH);
